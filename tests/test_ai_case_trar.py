# The following case is generated by AI Code Copilot TRAE.

from unittest.mock import patch, MagicMock
from ucuu.decorator import ucuu


# Test the normal case where the proxy function is called successfully.
def test_ucuu_decorator_normal_case():
    mock_proxy_func = MagicMock(return_value="proxy_result")

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = mock_proxy_func
        mock_import.return_value = mock_module

        @ucuu("module.path.proxy_func", extra_arg="value")
        def origin_func(arg1, arg2="default"):
            return "origin_output"

        # Call the decorated function
        result = origin_func("value1", arg2="value2")

        # Verify the result and proxy function call
        assert result == "origin_output"
        mock_proxy_func.assert_called_once_with(
            arg1="value1",
            arg2="value2",
            extra_arg="value",
            origin_output="origin_output",
        )


# Test the case where the proxy function raises an exception.
def test_ucuu_decorator_proxy_raises_exception():
    mock_proxy_func = MagicMock(side_effect=ValueError("proxy error"))

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = mock_proxy_func
        mock_import.return_value = mock_module

        @ucuu("module.path.proxy_func")
        def origin_func():
            return "origin_output"

        # Even if the proxy function raises an exception, the original function's output is returned.
        result = origin_func()
        assert result == "origin_output"


# Test the case where the proxy function returns an exception object instead of raising it.
def test_ucuu_decorator_proxy_returns_exception():
    mock_proxy_func = MagicMock(return_value=ValueError("proxy error"))

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = mock_proxy_func
        mock_import.return_value = mock_module

        @ucuu("module.path.proxy_func")
        def origin_func():
            return "origin_output"

        # The original function's output is returned regardless of the proxy function's return value.
        result = origin_func()
        assert result == "origin_output"


# Test the case where the proxy function's module cannot be imported.
def test_ucuu_decorator_import_failure():
    with patch("importlib.import_module") as mock_import:
        mock_import.side_effect = ImportError("module not found")

        @ucuu("invalid.module.proxy_func")
        def origin_func():
            return "origin_output"

        # The original function's output is returned when the module import fails.
        result = origin_func()
        assert result == "origin_output"


# Test the case where the proxy function is missing in the imported module.
def test_ucuu_decorator_missing_proxy_func():
    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = None
        mock_import.return_value = mock_module

        @ucuu("module.path.missing_func")
        def origin_func():
            return "origin_output"

        # The original function's output is returned when the proxy function is missing.
        result = origin_func()
        assert result == "origin_output"


# Test the case where the decorator is applied to a class method.
def test_ucuu_decorator_class_method():
    mock_proxy_func = MagicMock(return_value="proxy_result")

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = mock_proxy_func
        mock_import.return_value = mock_module

        class TestClass:
            @ucuu("module.path.proxy_func")
            def method(self, arg):
                return "origin_output"

        obj = TestClass()
        result = obj.method("value")
        assert result == "origin_output"
        mock_proxy_func.assert_called_once_with(
            arg="value", origin_output="origin_output"
        )


# Test the case where the decorated function has various argument bindings and default values.
def test_ucuu_decorator_args_binding():
    mock_proxy_func = MagicMock(return_value="proxy_result")

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.proxy_func = mock_proxy_func
        mock_import.return_value = mock_module

        @ucuu("module.path.proxy_func")
        def origin_func(a, b=2, c=3, *args, **kwargs):
            return "origin_output"

        # Call the decorated function with different argument combinations.
        origin_func(1)
        origin_func(1, 22)
        origin_func(1, c=33)
        origin_func(1, 22, 33, 44, d=66)

        # Verify the proxy function calls with the correct arguments.
        calls = mock_proxy_func.call_args_list
        assert calls[0][1] == {
            "a": 1,
            "b": 2,
            "c": 3,
            "args": (),
            "kwargs": {},
            "origin_output": "origin_output",
        }
        assert calls[1][1] == {
            "a": 1,
            "b": 22,
            "c": 3,
            "args": (),
            "kwargs": {},
            "origin_output": "origin_output",
        }
        assert calls[2][1] == {
            "a": 1,
            "b": 2,
            "c": 33,
            "args": (),
            "kwargs": {},
            "origin_output": "origin_output",
        }
        assert calls[3][1] == {
            "a": 1,
            "b": 22,
            "c": 33,
            "args": (44,),
            "kwargs": {"d": 66},
            "origin_output": "origin_output",
        }
